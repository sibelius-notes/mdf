---
title: CS 360 - Introduction to Theory of Computing
layout: toc
parent: Winter 2021
---
This set of notes is basically  from the [Watrous text](https://cs.uwaterloo.ca/~watrous/ToC-notes/ToC-notes.pdf) with some addons and comments from the instructor or myself. This term, we are following [Version of June 17, 2017](https://student.cs.uwaterloo.ca/~cs360/cs360notes.pdf).

Also note that this set of notes is incomplete, inaccurate with some statements. It serves quick reference to Wastrous' text.

# Lec 1
Important idea:
> Computational problems, devices, and processes can themselves be viewed as
mathematical objects.

If you want to avoid this sort of paradox (Russell's), you need to replace naïve set theory
with axiomatic set theory, which is quite a bit more formal and disallows objects
such as the set of all sets (which is what opens the door to let in Russell’s paradox). For more interesting discussion, check [PMATH 433](/pmath433).

## Sets and countability

The **size** of a finite set is the number of elements if contains. If <span>&#92;(A &#92;)</span> is a finite set, then we write <span>&#92;(&#124; A &#124; &#92;)</span> to denote this number. Sets can also be infinite. Note that in this course, we will include 0 as a natural number.

Definition 1.1
: A set <span>&#92;(A &#92;)</span> is countable if either (i) <span>&#92;(A &#92;)</span> is empty, or (ii) there exists an
onto (or surjective) function of the form <span>&#92;(f:\mathbb N \to A &#92;)</span>. If a set is not countable, then
we say that it is uncountable.

These three statements are equivalent for any choice of a set <span>&#92;(A &#92;)</span>:
1. <span>&#92;(A &#92;)</span> is countable.
2. There exists a one-to-one (or injective) function of the form <span>&#92;(g:A\to \mathbb N &#92;)</span>.
3. Either <span>&#92;(A &#92;)</span> is finite or there exists a one-to-one and onto (or bijective) function of
the form <span>&#92;(h:\mathbb N\to A &#92;)</span>.

Definition 1.5
: For any set <span>&#92;(A &#92;)</span>, the power set of <span>&#92;(A &#92;)</span> is the set <span>&#92;(\mathcal P(A) &#92;)</span> containing all subsets of <span>&#92;(A &#92;)</span>: <span>&#92;(\mathcal P(A) &#92;left&#92;{ B:B\subseteq A &#92;right&#92;}&#92;)</span>.

Theorem 1.6
: (Cantor). The power set of the natural numbers is uncountable.

Proof omitted (page 10).  The method used in the proof above is called diagonalization, for reasons we will
discuss later in the course. This is a fundamentally important proof technique in
the theory of computation.

## Alphabets, strings, and languages
Definition 1.7
: An alphabet is a finite and nonempty set.

Typical names for alphabets in this course are capital Greek letters. We typically refer to elements of alphabets as symbols, and we will often
use lower-case Greek letters.

Definition 1.8
: Let <span>&#92;(\Sigma &#92;)</span> be an alphabet. A string over alphabet <span>&#92;(\Sigma &#92;)</span> is a finite, ordered sequence of symbols from <span>&#92;(\Sigma &#92;)</span>. The length of a string is the total number of symbols in the sequence.

There is a special string, called the empty string and denoted <span>&#92;(\varepsilon &#92;)</span>, that has no symbols in it (and therefore it has length 0). It is a string over every alphabet.

Definition 1.9
: Let <span>&#92;(\Sigma &#92;)</span> be an alphabet. A language over <span>&#92;(\Sigma &#92;)</span>  is a set of strings, with each string being a string over the alphabet <span>&#92;(\Sigma &#92;)</span>.

A simple but nevertheless important example of a language over a given alphabet <span>&#92;(\Sigma &#92;)</span> is the set of *all* strings over <span>&#92;(\Sigma &#92;)</span>. We denote this language as <span>&#92;(\Sigma^* &#92;)</span>.

In this course, lower-case Roman letters at the end of the alphabet (u, v, w, x, y, z): strings. Capital Roman letters near the beginning of
the alphabet (A, B, C, D): languages.

# Lec 2
##  Countability and languages

Proposition 2.1
: For every alphabet <span>&#92;(\Sigma &#92;)</span>, the language <span>&#92;(\Sigma^* &#92;)</span> is countable.

In this course, lexicographic order means strings are ordered first by length,
and by “dictionary” ordering among strings of the same length.

TFAE, for any choice of an alphabet <span>&#92;(\Sigma &#92;)</span>:
1. <span>&#92;(A &#92;)</span> is a language over the alphabet <span>&#92;(\Sigma &#92;)</span>.
2. <span>&#92;(A\subseteq \Sigma^* &#92;)</span>.
3. <span>&#92;(A\in \mathcal P(\Sigma^*) &#92;)</span>.

Proposition 2.3
: Let <span>&#92;(\Sigma &#92;)</span> be an alphabet. The set <span>&#92;(P(\Sigma^*) &#92;)</span> is uncountable.

## Deterministic finite automata
Definition 2.4
: A deterministic finite automaton (or DFA, for short) is a 5-tuple <span>&#92;(M=(Q,\Sigma, \delta, q _ 0, F), &#92;)</span> where <span>&#92;(Q &#92;)</span> is a finite  and nonempty set (whose elements we will call states), <span>&#92;(\Sigma &#92;)</span> is an alphabet, <span>&#92;(\delta &#92;)</span> is a function (called the transition function) having the form <span>&#92;(\delta: Q\times \Sigma \to Q, &#92;)</span> <span>&#92;(q _ 0\in Q &#92;)</span> is a state (called the start state), and <span>&#92;(F\subseteq Q &#92;)</span> is a subset of states (whose
elements we  will call accept states).

See page 17 for an example of DFA.

Note from cs 241, [Carmen's slide](https://cs.uwaterloo.ca/~cbruni/CS241Resources/lectures/2019_Winter/CS241L06_formal_languages_and_dfas_post.pdf), in this course (cs 360),
> Some people allow a transition diagram to omit some of the arrows out of a state.
Implicitly, such transitions cause the automaton to reject. For this course, however,
DO NOT omit any arrows for a DFA. There is no implicit state for “always reject”;
if you want one specify it explicitly. (For the case of an NFA, see later.)

from the instructor's comment.


### DFA computations
We already know what it means for a DFA to accept or reject a given input string <span>&#92;(w\in \Sigma^* &#92;)</span>.

Definition 2.5
: Let <span>&#92;(M=(Q,\Sigma, \delta, q _ 0, F) &#92;)</span> be a DFA and let <span>&#92;(w\in \Sigma^* &#92;)</span> be a string. The DFA M accepts the string <span>&#92;(w &#92;)</span> if one of the following statements holds:
1. <span>&#92;(w = \varepsilon &#92;)</span> and <span>&#92;(q _ 0\in F &#92;)</span>.
2. <span>&#92;(w=\sigma _ 1\cdots \sigma _ n  &#92;)</span> for a positive integer <span>&#92;(n &#92;)</span> and symbols <span>&#92;(\sigma _ 1,\ldots, \sigma _ n \in \Sigma &#92;)</span>, and there exist states <span>&#92;(r _ 0, \ldots, r _ n \in Q &#92;)</span> such that <span>&#92;(r _ 0 = q _ 0, r _ n \in F &#92;)</span>, and <span>&#92;(r _ {k+1} = \delta (r _ k, \delta _ {k+1}) &#92;)</span> for all <span>&#92;(k \in &#92;left&#92;{ 0, \ldots, n-1 &#92;right&#92;} &#92;)</span>.

If <span>&#92;(M &#92;)</span> does not accept <span>&#92;(w &#92;)</span>, then <span>&#92;(M &#92;)</span> rejects <span>&#92;(w &#92;)</span>.

It's sometimes useful to define a new function <span>&#92;(\delta ^ * : Q\times \Sigma^ * \to Q &#92;)</span>. Intuitively speaking, <span>&#92;(\delta^* (q, w) &#92;)</span> is the state you end up on if you start at state <span>&#92;(q &#92;)</span> and follow the transitions specified by the string <span>&#92;(w &#92;)</span>.

### Languages recognized by DFAs and regular languages
Suppose <span>&#92;(M &#92;)</span> is a DFA. We may then consider the set of all strings
that are accepted by M. This language is denoted
<span>&#92;[
    {\rm L}(M) = &#92;left&#92;{ w\in \Sigma^* : M \text{ accepts }w &#92;right&#92;}.
&#92;]</span>
We e refer to this as the language recognized by <span>&#92;(M &#92;)</span>.

Definition 2.7
: Let <span>&#92;(\Sigma &#92;)</span> be an alphabet and let <span>&#92;(A\subseteq \Sigma^* &#92;)</span> be a language over <span>&#92;(\Sigma &#92;)</span>. The language <span>&#92;(A &#92;)</span> is regular if there exists a DFA <span>&#92;(M &#92;)</span> such that <span>&#92;(A={\rm L}(M) &#92;)</span>.

For a given alphabet <span>&#92;(\Sigma &#92;)</span>,
 the number of regular languages over the
alphabet <span>&#92;(\Sigma &#92;)</span> is countable.

Because there are uncountably many languages <span>&#92;(A\subseteq \Sigma^* &#92;)</span>, and only countably many regular languages <span>&#92;(A\subseteq \Sigma^* &#92;)</span>, we can immediately conclude that some languages are not regular.

# Lec 3
## Nondeterministic finite automata basics
Definition 3.1
: A nondeterministic finite automaton (or NFA, for short) is a 5-tuple <span>&#92;(N = (Q, \Sigma, \delta, q _ 0, F) &#92;)</span>, where Q finite & nonempty set of states, Σ is an alphabet, δ is a transition
function having the form <span>&#92;(\delta: Q\times (\Sigma \cup &#92;left&#92;{ \varepsilon &#92;right&#92;}) \to \mathcal P(Q) &#92;)</span>, q<sub>0</sub> start state, F is a subset of accept states.

Key diff between this and DFA is the transition function. For DFA, <span>&#92;(\delta(q, \sigma) &#92;)</span> was a state. For NFA, each <span>&#92;(\delta (q,\delta) &#92;)</span> is not a state, but rather a subset of states. This subset represents all of the
possible states that the NFA could move to when in state q and reading symbol σ. Even possible to have δ(q, σ) = ∅.

Also note we allow <span>&#92;(\varepsilon &#92;)</span>-transitions, where an NFA may move from one state to another without
reading a symbol from the input. See [Carmen's slides](https://cs.uwaterloo.ca/~cbruni/CS241Resources/lectures/2019_Winter/CS241L08_nfas_epsilon_post.pdf) on epsilon transitions.

Definition 3.2
: Let <span>&#92;(N &#92;)</span> be an NFA and <span>&#92;(w\in \Sigma^* &#92;)</span> be a string. The NFA A accepts w if <span>&#92;(\exists m\in \mathbb N &#92;)</span>, a sequence of states <span>&#92;(r _ 0,\ldots, r _ m &#92;)</span>, and a sequence of either symbols or empty strings <span>&#92;(\sigma _ 1,\ldots, \sigma _ m\in \Sigma \cup &#92;left&#92;{ \varepsilon &#92;right&#92;} &#92;)</span> such that the following statements all hold:
1. <span>&#92;(r _ 0 = q _ 0 &#92;)</span>
2. <span>&#92;(r _ m \in F &#92;)</span>
3. <span>&#92;(w = \sigma _ 1 \cdots \sigma _ m &#92;)</span>
4. <span>&#92;(r _ {k+1}\in \delta ( r _ k, \sigma _ {k+1}) &#92;)</span> for every k = 0, ..., m-1

If <span>&#92;(N &#92;)</span> does not accept <span>&#92;(w &#92;)</span>, then <span>&#92;(N &#92;)</span> rejects <span>&#92;(w &#92;)</span>.

Along similar lines to what we did for DFAs, we can define an extended version
of the transition function of an NFA. We define a new function <span>&#92;(\delta^* : Q \times \Sigma ^ * \to \mathcal P(Q) &#92;)</span> as follows.

First we define <span>&#92;(\varepsilon &#92;)</span>-closure of any set <span>&#92;(R\subseteq R &#92;)</span> as <span>&#92;(\varepsilon (R) &#92;)</span> = {q ∈ Q : q is reachable from some r ∈ R by following
zero or more ε-transitions }. We can interpret this alternative definition as saying that <span>&#92;(\varepsilon (R) &#92;)</span> is the smallest subset
of Q that contains R and is such that you can never get out of this set by following
an ε-transition.

Then we can recursively define δ<sup>*</sup> (details omitted).

Intuitively speaking, δ<sup>*</sup>(q, w) is the set of all states that you could potentially reach
by starting on the state q, reading w, and making as many ε-transitions along the
way as you like.

Also similar to DFAs, the notion L(N) denotes the language recognized by an NFA N:
<span>&#92;[
    {\rm L}(N)= &#92;left&#92;{ w\in \Sigma^* : N \text{ accepts }w &#92;right&#92;}.
&#92;]</span>

## Equivalence of NFAs and DFAs

Theorem 3.3
: Let <span>&#92;(\Sigma &#92;)</span> be an alphabet and let <span>&#92;(A \subseteq \Sigma ^ * &#92;)</span> be a language. The language <span>&#92;(A &#92;)</span> is regular (i.e., recognized by a DFA) iff <span>&#92;(A={\rm L}(N) &#92;)</span> for some NFA <span>&#92;(N &#92;)</span>.

Simple: regular <span>&#92;(\implies &#92;)</span> NFA... We will use the description of an NFA N to define an equivalent DFA M using
a simple idea: each state of M will keep track of a subset of states of N.

# Lec 4
In this lecture we will discuss the regular operations, as well as regular expressions
and their relationship to regular languages.
## Regular operations
Definition 4.1
: Let <span>&#92;(\Sigma &#92;)</span> be an alphabet and let <span>&#92;(A,B\subseteq \Sigma^* &#92;)</span> be languages. The regular operations are as follows:
1. Union: <span>&#92;(A\cup B = &#92;left&#92;{ w: w\in A\text{ or }w\in B &#92;right&#92;} &#92;)</span>
2. Concatenation: <span>&#92;(AB = &#92;left&#92;{ wx: w\in A\text{ and }x\in B &#92;right&#92;} &#92;)</span>
3. Kleene star (or just star): <span>&#92;(A^* = &#92;left&#92;{ \varepsilon &#92;right&#92;} \cup A \cup AA \cup AAA\cup \cdots &#92;)</span>

In words, <span>&#92;(A^* &#92;)</span>
is the language obtained by selecting any finite number of strings
from A and concatenating them together. (This includes the possibility to select
no strings at all from A, where we follow the convention that concatenating
together no strings at all gives the empty string.)

Theorem 4.2
: The regular languages are closed with respect to the regular operations: if <span>&#92;(A,B\subseteq \Sigma^* &#92;)</span>
are regular languages, then the languages A ∪ B, AB, and A<sup>∗</sup>
are also regular.

*Proof.* define such NFAs.

Note that we cannot easily conclude <span>&#92;(A^* &#92;)</span> is regular (for a regular language A) using
 the facts that the regular languages are closed under union
and concatenation. We can only conclude finite unions is regular, not for infinite unions.

## Other closure properties of regular languages
Definition 4.3
: Let <span>&#92;(A\subseteq \Sigma^* &#92;)</span> be a language over the alphabet <span>&#92;(\Sigma &#92;)</span>. The complement of <span>&#92;(A &#92;)</span>: <span>&#92;(\bar A=\Sigma^* \setminus A &#92;)</span>.

Proposition 4.4
: Let <span>&#92;( A &#92;)</span> be a regular language. <span>&#92;(\bar A &#92;)</span> is also regular.

Proposition 4.5
： Let <span>&#92;( A, B &#92;)</span> be regular languages. <span>&#92;(A\cap B &#92;)</span> is also regular.

*Proof*: <span>&#92;(A\cap B = \overline{\bar A \cup \bar B} &#92;)</span>

## Regular expressions
Definition 4.6
: alphabet <span>&#92;(\Sigma &#92;)</span>. R is a regular expression over the
alphabet Σ if any of these holds:
1. <span>&#92;(R= \varnothing &#92;)</span>.
2. <span>&#92;(R=\varepsilon &#92;)</span>.
3. <span>&#92;(R=\sigma &#92;)</span> for some choice of <span>&#92;(\sigma\in \Sigma &#92;)</span>.
4. <span>&#92;(R = (R _ 1\cup R _ 2) &#92;)</span>
5. <span>&#92;(R = (R _ 1  R _ 2) &#92;)</span>
6. <span>&#92;(R = (R _ 1^*) &#92;)</span>.

Definition 4.7
: Let R be a regular expression over the alphabet Σ. The language
recognized by R, which is denoted L(R), is defined as follows:
1. <span>&#92;(R=\varnothing \implies L(R)=\varnothing &#92;)</span>
2. <span>&#92;(R=\varepsilon \implies L(R)=&#92;left&#92;{ \varepsilon &#92;right&#92;} &#92;)</span>
3. <span>&#92;(R=\sigma \implies L(R)=&#92;left&#92;{ \sigma &#92;right&#92;} &#92;)</span>
4. <span>&#92;(R=(R _ 1 \cup R _ 2) \implies L(R)= L(R _ 1)\cup L(R _ 2) &#92;)</span>
5. <span>&#92;(R=(R _ 1  R _ 2) \implies L(R)= L(R _ 1) L(R _ 2) &#92;)</span>
6. <span>&#92;(R=(R _ 1 ^ * ) \implies L(R)= L(R _ 1) ^ * &#92;)</span>

Order of precedence for regular operations
1. star (highest precedence)
2. concatenation
3. union (lowest precedence).

Proposition 4.8
: Let Σ be an alphabet and let R be a regular expression over the alphabet Σ. It holds that the language L(R) is regular.

Theorem 4.9
: Let Σ be an alphabet and let A ⊆ Σ<sup>*</sup>
be a regular language. There exists a
regular expression over the alphabet Σ such that L(R) = A.

Theorem 4.9 (together with Prop. 4.8) is known as “Kleene’s Theorem”. It is not at all obvious; perhaps even unbelievable at first.

# Lec 5
## The pumping lemma (for regular languages)

Lemma 5.1
: (Pumping lemma for regular languages). Let <span>&#92;(\Sigma &#92;)</span> be an alphabet and let <span>&#92;(A\subseteq \Sigma^* &#92;)</span> be a regular language. There exists a positive integer <span>&#92;(n &#92;)</span> (called a pumping length of <span>&#92;(A &#92;)</span>) that possesses the following property. For every string <span>&#92;(w\in A &#92;)</span> with <span>&#92;(|w|\ge n &#92;)</span>, it is possible to write <span>&#92;(w=xyz &#92;)</span> for some choice of strings <span>&#92;(x,y,z\in \Sigma^* &#92;)</span> such that 
1. <span>&#92;(y\ne \varepsilon &#92;)</span>,
2. <span>&#92;(|xy|\le n &#92;)</span>, and 
3. <span>&#92;(xy^i z\in A &#92;)</span> for all <span>&#92;(i\in \mathbb N &#92;)</span>.

The pumping lemma is essentially a precise, technical way of expressing one
simple consequence of the following fact:
> If a DFA with n or fewer states reads n or more symbols from an input
string, at least one of its states must have been visited more than once.

## Using the pumping lemma to prove nonregularity

We can use the pumping lemma to prove that certain languages are *not* regular using the technique of
proof by contradiction. In particular, we take the following steps:
1. For A being the language we hope to prove is nonregular, we make the assumption that A is regular. Operating under the assumption that the language A is
regular, we are free to apply the pumping lemma to it.
2. Using the property that the pumping lemma establishes for A, we derive a
contradiction. Just about always the contradiction will be that we conclude that
some particular string is contained in A that we know is actually not contained
in A.
3. Having derived a contradiction, we conclude that it was our assumption that A
is regular that led to the contradiction, and so we conclude that A is nonregular.

Proposition 5.2
: Let <span>&#92;(\Sigma = &#92;left&#92;{ 0,1 &#92;right&#92;} &#92;)</span> be the binary alphabet and define a language over <span>&#92;(\Sigma &#92;)</span> as follows: <span>&#92;(A= &#92;left&#92;{ 0^m1^m:m\in \mathbb N &#92;right&#92;} &#92;)</span> is not regular.

*Proof.* Follow the procedure above.

Proposition 5.3
: Let <span>&#92;(\Sigma=&#92;left&#92;{ 0,1 &#92;right&#92;} &#92;)</span> be the binary alphabet and define a language over <span>&#92;(\Sigma &#92;)</span> as follows: <span>&#92;(B=&#92;left&#92;{ 0^m1^r:m,n\in \mathbb N, m>r &#92;right&#92;} &#92;)</span> is not regular.

*Proof.* Follow the procedure above.

Proposition 5.5
: Let <span>&#92;(\Sigma = &#92;left&#92;{ 0 &#92;right&#92;} &#92;)</span> and define a language over <span>&#92;(\Sigma &#92;)</span> as follows: <span>&#92;(C= &#92;{  0^m:m &#92;)</span> is a perfect square <span>&#92;(&#92;} &#92;)</span> is not regular.

*Proof.* Follow the procedure above.

Notation: <span>&#92;(w^R &#92;)</span> denotes the reverse of the string <span>&#92;(w &#92;)</span>.

Proposition 5.6
: Let <span>&#92;(\Sigma = &#92;left&#92;{ 0,1 &#92;right&#92;} &#92;)</span> and define a language over <span>&#92;(\Sigma &#92;)</span> as follows: &#92;left&#92;{ D= &#92;left&#92;{ w\in \Sigma^*: w = w^R &#92;right&#92;} &#92;right&#92;} is not regular.

*Proof.* Follow the procedure above.

## Nonregularity from closure properties

Proposition 5.7
: Let <span>&#92;(\Sigma =&#92;left&#92;{ 0,1 &#92;right&#92;} &#92;)</span> and define a language over <span>&#92;(\Sigma &#92;)</span> as follows: <span>&#92;(E=&#92;left&#92;{ w\in \Sigma^*: w \ne w^R &#92;right&#92;} &#92;)</span> is not regular.

*Proof.* Regular languages are closed under complementation.

Proposition 5.8
: Let <span>&#92;(\Sigma = &#92;left&#92;{ 0,1 &#92;right&#92;} &#92;)</span> and define a language over <span>&#92;(\Sigma &#92;)</span> as follows: <span>&#92;(F= &#92;{ w\in \Sigma^*:  w &#92;)</span> has more 0s than 1s <span>&#92;(&#92;} &#92;)</span> is not regular.

*Proof.* Regular languages are closed under intersection: <span>&#92;(F\cap L(0 ^ * 1 ^ *)=B &#92;)</span>.

# Lec 6
## Other operations on languages
Reverse: 
- <span>&#92;(w \in \Sigma^* \xrightarrow{reverse} w^R &#92;)</span> (formal definition omitted).
- <span>&#92;(A \subseteq \Sigma^* \xrightarrow{reverse} A^R = &#92;left&#92;{ w^R:w\in A &#92;right&#92;} &#92;)</span>

Proposition 6.1
: Let <span>&#92;(\Sigma &#92;)</span> be an alphabet and let <span>&#92;(A\subseteq \Sigma^* &#92;)</span> be a regular language. The language <span>&#92;(A^R &#92;)</span> is regular.