---
title: CS 360 - Introduction to Theory of Computing
layout: toc
parent: Winter 2021
---
This set of notes is basically  from the [Watrous text](https://cs.uwaterloo.ca/~watrous/ToC-notes/ToC-notes.pdf) with some addons and comments from the instructor or myself. This term, we are following [Version of June 17, 2017](https://student.cs.uwaterloo.ca/~cs360/cs360notes.pdf).

# Course overview and mathematical foundations
Important idea:
> Computational problems, devices, and processes can themselves be viewed as
mathematical objects.

If you want to avoid this sort of paradox (Russell's), you need to replace naïve set theory
with axiomatic set theory, which is quite a bit more formal and disallows objects
such as the set of all sets (which is what opens the door to let in Russell’s paradox). For more interesting discussion, check [PMATH 433](/pmath433).

## Sets and countability

The **size** of a finite set is the number of elements if contains. If <span>&#92;(A &#92;)</span> is a finite set, then we write <span>&#92;(&#124; A &#124; &#92;)</span> to denote this number. Sets can also be infinite. Note that in this course, we will include 0 as a natural number.

Definition 1.1
: A set <span>&#92;(A &#92;)</span> is countable if either (i) <span>&#92;(A &#92;)</span> is empty, or (ii) there exists an
onto (or surjective) function of the form <span>&#92;(f:\mathbb B \to A &#92;)</span>. If a set is not countable, then
we say that it is uncountable.

These three statements are equivalent for any choice of a set <span>&#92;(A &#92;)</span>:
1. <span>&#92;(A &#92;)</span> is countable.
2. There exists a one-to-one (or injective) function of the form <span>&#92;(g:A\to \mathbb N &#92;)</span>.
3. Either <span>&#92;(A &#92;)</span> is finite or there exists a one-to-one and onto (or bijective) function of
the form <span>&#92;(h:\mathbb N\to A &#92;)</span>.

Definition 1.5
: For any set <span>&#92;(A &#92;)</span>, the power set of <span>&#92;(A &#92;)</span> is the set <span>&#92;(\mathcal P(A) &#92;)</span> containing all subsets of <span>&#92;(A &#92;)</span>: <span>&#92;(\mathcal P(A) &#92;left&#92;{ B:B\subseteq A &#92;right&#92;}&#92;)</span>.

Theorem 1.6
: (Cantor). The power set of the natural numbers is uncountable.

Proof omitted (page 10).  The method used in the proof above is called diagonalization, for reasons we will
discuss later in the course. This is a fundamentally important proof technique in
the theory of computation.

## Alphabets, strings, and languages
Definition 1.7
: An alphabet is a finite and nonempty set.

Typical names for alphabets in this course are capital Greek letters. We typically refer to elements of alphabets as symbols, and we will often
use lower-case Greek letters.

Definition 1.8
: Let <span>&#92;(\Sigma &#92;)</span> be an alphabet. A string over alphabet <span>&#92;(\Sigma &#92;)</span> is a finite, ordered sequence of symbols from <span>&#92;(\Sigma &#92;)</span>. The length of a string is the total number of symbols in the sequence.

There is a special string, called the empty string and denoted <span>&#92;(\epsilon &#92;)</span>, that has no symbols in it (and therefore it has length 0). It is a string over every alphabet.

Definition 1.9
: Let <span>&#92;(\Sigma &#92;)</span> be an alphabet. A language over <span>&#92;(\Sigma &#92;)</span>  is a set of strings, with each string being a string over the alphabet <span>&#92;(\Sigma &#92;)</span>.

A simple but nevertheless important example of a language over a given alphabet <span>&#92;(\Sigma &#92;)</span> is the set of *all* strings over <span>&#92;(\Sigma &#92;)</span>. We denote this language as <span>&#92;(\Sigma^* &#92;)</span>.

In this course, lower-case Roman letters at the end of the alphabet (u, v, w, x, y, z): strings. Capital Roman letters near the beginning of
the alphabet (A, B, C, D): languages.

# Countability for languages and deterministic finite automata
##  Countability and languages

Proposition 2.1
: For every alphabet <span>&#92;(\Sigma &#92;)</span>, the language <span>&#92;(\Sigma^* &#92;)</span> is countable. 
